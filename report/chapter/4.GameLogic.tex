%========================================================================================
% TU Dortmund, Informatik Lehrstuhl VII
%========================================================================================

\chapter{Spiel Logik}
\label{Spiel_Logik}
%
In diesem Kapitel gehen wir auf die Hauptfunktion des eigentlichen Spielablaufs, $vGameScreen()$, und der daf{\"u}r ben{\"o}tigten einzelnen Funktionen ein. Wie in den meisten Computerspielen besteht die Hauptfunkion im groben aus einer einzigen gro{\ss}en Schleife, in der zum der aktuelle Spielzustand abh{\"a}ngig von den Eingaben der Spieler ge{\"a}ndert wird, und zum anderen der aktuelle Spielzustand grafisch aufgearbeitet und auf den Bildschirm gebracht wird. Vor dem Start dieser Schleife findet noch eine Initialisierung statt, welche den Spielzustand auf den Anfang des Spiels setzt.
%

\section{Initialisierung}
\label{Initialisierung}
%
Das erste, was nach Starten des Spiel geschieht, ist das Erstellen eine Art $seed$ f{\"u}r die $rand()$ Funktion der C - Programmiersprache. Da die $rand()$ Funktion die verstrichene Zeit seit Aufruf der Funktion in der sie aufgerufen wird als Basis f{\"u}r die Berechnung der Pseudozufallszahl nimmt, die ersten Aufrufe der $rand()$ Funktion immer die gleichen Werte zur{\"u}ckgeben, und somit die Schlangen der Spieler sowie das erste $foodElement$ immer an der gleichen Stelle starten. Um den entgegenzuwirken berechnet die Funktion als erstes die letzten beiden Ziffern des Produkts der x- und y-Koordinaten der Mausposition beim klicken des Start-Buttons und dekrementiert diese Zahl bis zur null. Durch diese minimale verstrichene Zeitspanne {\"a}ndern sich die Ergebnisse der ersten $rand()$-Aufrufe und damit der Startzustand des Spielfelds, vorrausgesetzt man dr{\"u}ckt beim Start nicht auf den exakt gleichen Pixel wie vorher.
Anschlie{\ss}end werden, je nach gew{\"a}hltem Level, die W{\"a}nde sowie alle weiteren festen Elemente des Levels an ihre entsprechenden Stellen ins $fieldArray$ geschrieben.
Daraufhin werden die Variablen f{\"u}r die Position der beiden Spieler, $p1X, p1Y, p2X$ und $p2Y$, sowie das erste $foodElement$, auf zuf{\"a}llige Positionen im Spielfeld gesetzt. Dafür werden die beiden Funktionen $getRandomFreeField$, welche mit der Methode beschrieben im Kapitel \ref{Elemente Erzeugen}  : \nameref{Elemente Erzeugen} eine freie Stelle auf dem Spielfeld zurückgibt, und $createRandomFood()$, welches auf einer zufälligen Stelle des Feldes ein $foodElement$ erschafft, also die zugehörige Stelle im $fieldArray()$ mit der Nummer $10$ beschreibt sowie die Variablen $food1X, food1Y$ bzw. $food2X, food2Y$ auf die zugehörigen Koordinaten auf dem Bildschirm setzt. Außerdem werden die zugeh{\"o}rigen verketteten Listen f{\"u}r die Schlangen mit bereits 2 weiteren "Schlangenteilen" initialisiert. Dies geschieht auch im Singleplayer-Modus f{\"u}r die Schlange von Spieler 2, da der Code ansonsten aufgrund einer m{\"o}glicherweise nicht initialisierten Spieler-2-Schlange nicht kompiliert. Einzig der Eintrag im $fieldArray()$  wird im Singleplayer-Modus ausgelassen, da offensichtlich kein Spieler 2 existiert.
Zum Schluss werden noch die boolean-Variablen $p1Ready$ und $p2Ready$ auf $false$ sowie $initial$ auf $true$ gesetzt. Diese werden in der nun startenden Hauptschleife benötigt.
Jetzt ist das Spielfeld soweit initialisiert, dass das eigentliche Spiel beginnen kann.
%

\section{Hauptschleife}
\label{Hauptschleife}
%
Wenn das Spiel fertig initialisiert ist startet die Hauptschleife. Da die Variable $initial$ in der Initialisierung auf $false$ gesetzt ist, startet das Spiel nicht direkt, statdessen wird nur der Startzustand, also die Startposition der Schlange sowie die ersten $foodElemente$ angezeigt, sowie eine kurze Animation gezeigt, in der das Level gezeichnet wird. Dadurch können sich die Spieler zuerst mit dem Level vertraut machen und können in Ruhe ihre Startrichtung ausmachen, so dass das Spiel erst startet wenn alle bereit sind. Wenn nun der oder die Spieler eine ihrer Richtungstasten betätigen, wird zum einen die Startrichtung für die Schlangen gesetzt, sowie die zum jeweiligen Spieler gehörige $ready$-Variable auf $true$ gesetzt. Erst wenn die $ready$-Variablen aller Spieler auf $true$ stehen, wird die $initial$-Variable auf $false$ gesetzt und das eigentliche Spiel startet, die Schlangen fangen an sich zu bewegen. Sollte zu diesem Zeitpunkt die Animation des Levels noch nicht abgeschlossen sein, so wird diese abgebrochen und das Level einfach direkt vollständig angezeigt.
Wenn dies alles geschehen ist startet das eigentliche Spiel, und es geschieht jeden Schleifendurchlauf das gleiche, solange bis das Spiel endet in dem einer der Spieler verliert.
Zuerst wird der Zustand der Tastatur durch die Funktion $xGetButtonInput()$ abgerufen, sodass basierend auf den Tastatur-Eingaben der neue Spielzustand berechnet werden kann. Die beiden Funktionen $pause()$ und $infoscreen()$ steuern das pausieren oder weiterführen des Spiels nach dem Drücken der Taste "P" sowie das anzeigen oder verstecken des Hilfe-Textes am unteren Rand des Bildschirms nach Drücken der Taste "I". Mit der Funktion $incrementSpeed()$ überprüft das Spiel, ob einer der Spieler die größe 25, 50, 75 oder 100 erreicht hat, und falls ja, erhöht es die Spielgeschwindigkeit. Die Funktion $checkGameOver$ überprüft, ob einer der Kriterien für ein Ende des Spiels erfüllt sind, also ob einer der Spieler verloren hat. Ist dies der Fall stoppt die Funktion die Bewegung der Schlangen und startet die Game-Over-Animation und zeigt die Button für einen Neustart, die Highscoreliste und das Hauptmenü ein. Außerdem wird, falls ein Highscore erreicht wurde, dieser in die Highscorelsite eingetragen.

%


   

%
