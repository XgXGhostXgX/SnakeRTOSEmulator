%========================================================================================
% TU Dortmund, Informatik Lehrstuhl VII
%========================================================================================

\chapter{Spiellogik}
\label{Spiel_Logik}
%
In diesem Kapitel gehen wir auf die Hauptfunktion des eigentlichen Spielablaufs, $vGameScreen()$, und der daf{\"u}r ben{\"o}tigten einzelnen Funktionen ein. Wie in den meisten Computerspielen besteht die Hauptfunkion im groben aus einer einzigen gro{\ss}en Schleife, in der zum der aktuelle Spielzustand abh{\"a}ngig von den Eingaben der Spieler ge{\"a}ndert wird, und zum anderen der aktuelle Spielzustand grafisch aufgearbeitet und auf den Bildschirm gebracht wird. Vor dem Start dieser Schleife findet noch eine Initialisierung statt, welche den Spielzustand auf den Anfang des Spiels setzt.
%

\section{Initialisierung}
\label{Initialisierung}
%
Das erste, was nach Starten des Spiel geschieht, ist das Erstellen eine Art $seed$ f{\"u}r die $rand()$ Funktion der C - Programmiersprache. Da die $rand()$ Funktion die verstrichene Zeit seit Aufruf der Funktion in der sie aufgerufen wird als Basis f{\"u}r die Berechnung der Pseudozufallszahl nimmt, die ersten Aufrufe der $rand()$ Funktion immer die gleichen Werte zur{\"u}ckgeben, und somit die Schlangen der Spieler sowie das erste $foodElement$ immer an der gleichen Stelle starten. Um den entgegenzuwirken berechnet die Funktion als erstes die letzten beiden Ziffern des Produkts der x- und y-Koordinaten der Mausposition beim klicken des Start-Buttons und dekrementiert diese Zahl bis zur null. Durch diese minimale verstrichene Zeitspanne {\"a}ndern sich die Ergebnisse der ersten $rand()$-Aufrufe und damit der Startzustand des Spielfelds, vorrausgesetzt man dr{\"u}ckt beim Start nicht auf den exakt gleichen Pixel wie vorher.
Anschlie{\ss}end werden, je nach gew{\"a}hltem Level, die W{\"a}nde sowie alle weiteren festen Elemente des Levels an ihre entsprechenden Stellen ins $fieldArray$ geschrieben.
Daraufhin werden die Variablen f{\"u}r die Position der beiden Spieler, $p1X, p1Y, p2X$ und $p2Y$, sowie das erste $foodElement$, auf zuf{\"a}llige Positionen im Spielfeld gesetzt. Dafür werden die beiden Funktionen $getRandomFreeField$, welche mit der Methode beschrieben im Kapitel \ref{Elemente Erzeugen}  : \nameref{Elemente Erzeugen} eine freie Stelle auf dem Spielfeld zurückgibt, und $createRandomFood()$, welches auf einer zufälligen Stelle des Feldes ein $foodElement$ erschafft, also die zugehörige Stelle im $fieldArray()$ mit der Nummer $10$ beschreibt sowie die Variablen $food1X, food1Y$ bzw. $food2X, food2Y$ auf die zugehörigen Koordinaten auf dem Bildschirm setzt. Außerdem werden die zugeh{\"o}rigen verketteten Listen f{\"u}r die Schlangen mit bereits 2 weiteren "Schlangenteilen" initialisiert. Dies geschieht auch im Singleplayer-Modus f{\"u}r die Schlange von Spieler 2, da der Code ansonsten aufgrund einer m{\"o}glicherweise nicht initialisierten Spieler-2-Schlange nicht kompiliert. Einzig der Eintrag im $fieldArray()$  wird im Singleplayer-Modus ausgelassen, da offensichtlich kein Spieler 2 existiert.
Zum Schluss werden noch die boolean-Variablen $p1Ready$ und $p2Ready$ auf $false$ sowie $initial$ auf $true$ gesetzt. Diese werden in der nun startenden Hauptschleife benötigt.
Jetzt ist das Spielfeld soweit initialisiert, dass das eigentliche Spiel beginnen kann.
%

\section{Hauptschleife}
\label{Hauptschleife}
%
Wenn das Spiel fertig initialisiert ist startet die Hauptschleife. Da die Variable $initial$ in der Initialisierung auf $false$ gesetzt ist, startet das Spiel nicht direkt, statdessen wird nur der Startzustand, also die Startposition der Schlange sowie die ersten $foodElemente$ angezeigt, sowie eine kurze Animation gezeigt, in der das Level gezeichnet wird. Dadurch können sich die Spieler zuerst mit dem Level vertraut machen und können in Ruhe ihre Startrichtung ausmachen, so dass das Spiel erst startet wenn alle bereit sind. Wenn nun der oder die Spieler eine ihrer Richtungstasten betätigen, wird zum einen die Startrichtung für die Schlangen gesetzt, sowie die zum jeweiligen Spieler gehörige $ready$-Variable auf $true$ gesetzt. Erst wenn die $ready$-Variablen aller Spieler auf $true$ stehen, wird die $initial$-Variable auf $false$ gesetzt und das eigentliche Spiel startet, die Schlangen fangen an sich zu bewegen. Sollte zu diesem Zeitpunkt die Animation des Levels noch nicht abgeschlossen sein, so wird diese abgebrochen und das Level einfach direkt vollständig angezeigt.
Wenn dies alles geschehen ist startet das eigentliche Spiel, und es geschieht jeden Schleifendurchlauf das gleiche, solange bis das Spiel endet in dem einer der Spieler verliert.
Zuerst wird der Zustand der Tastatur durch die Funktion $xGetButtonInput()$ abgerufen, sodass basierend auf den Tastatur-Eingaben der neue Spielzustand berechnet werden kann. Die beiden Funktionen $pause()$ und $infoscreen()$ steuern das pausieren oder weiterführen des Spiels nach dem Drücken der Taste "P" sowie das anzeigen oder verstecken des Hilfe-Textes am unteren Rand des Bildschirms nach Drücken der Taste "I". Mit der Funktion $incrementSpeed()$ überprüft das Spiel, ob einer der Spieler die größe 25, 50, 75 oder 100 erreicht hat, und falls ja, erhöht es die Spielgeschwindigkeit. Die Funktion $checkGameOver$ überprüft, ob einer der Kriterien für ein Ende des Spiels erfüllt sind, also ob einer der Spieler verloren hat. Ist dies der Fall stoppt die Funktion die Bewegung der Schlangen und startet die Game-Over-Animation und zeigt die Button für einen Neustart, die Highscoreliste und das Hauptmenü ein. Außerdem wird, falls ein Highscore erreicht wurde, dieser in die Highscoreliste eingetragen.
Anschließend wird mit $playerOneGetNextDirection()$ bzw $playerTwoGetNextDirection()$ die nächste Richtung der Schlangen bestimmt, wieso dafür eine extra Funktion benutzt wird erklären wir in Kapitel \ref{Bewegung der Schlange}  : \nameref{Bewegung der Schlange}.
Der anschließende Teil der Hauptschleife hängt von den beiden Variablen $frame$ und $frameTicks$ ab. $frame$ gibt die aktuelle Zahl der Schleifendurchläufe seit dem letzten Schritt der Schlangen an und wird somit nach jedem Schleifendurchlauf inkrementiert, während frameTicks die Zahl der benötigten Schleifendurchläufe für einen Schritt angibt. Wenn also $frame == frameticks$ gilt, führen die Schlangen einen Schritt aus und $frame$ wird wieder auf 0 gesetzt. Mit Hilfe dieser beiden Variablen werden auch weitere Elemente des Spiel gesteuert: Wenn das Spiel pausiert oder verloren ist wird $frame$ nicht weiter erhöht damit die Schlangen stehenbleiben, und zur Erhöhung der Laufgeschwindigkeit der Schlangen wird $frameticks$ von anfänglich 5 immer weiter dekrementiert. Wenn im Schleifendurchlauf nun $frames == frameticks$ gilt, geschieht folgendes: Aller Spieler machen mit der Funktion $playerStep()$ einen Schritt in ihre jeweiligen Richtungen. Dabei wird der Kopf der Schlange um eine Einheit in die aktuelle Richtung bewegt, ein neues Schlangenelement an der Stelle an der der Kopf war der Schlange hinzugefügt und die Stelle im $fieldArray$ mit der Spielernummer beschrieben, sowie das letzte Element der Schlange gelöscht und ihre zugehörige Stelle im $fieldArray$ wieder auf 0 gesetzt. Anschließend wird mit der Funktion $collisionDetection()$ überprüft, ob eine der Schlangen mit ihrem letzten Schritt mit etwas zusammengestoßen ist. Dafür wird der Wert des $fieldArray$ an der Stelle des Kopfes überprüft. Ist dieser Wert 1, 2 oder 3, hat der Spieler entweder die Schlange von Spieler 1 oder Spieler 2 oder die Wand getroffen und hat damit verloren. Aber auch das Aufsammeln eines $foodElements$ oder eines $PowerUps$ wird mit der Funktion überprüft. Bevor zum Schluss die Variable $frame$, wie vorher beschrieben, auf 0 gesetzt wird, wird mit der Funktion $powerUps()$ der Einsatz der einzelnen $PowerUps$ überprüft. Diese Mechanik erkläre ich im nachfolgenden Unterkapitel.
Danach muss nurnoch der aktuelle Spielzustand auf dem Bildschirm gez	eichnet werden ($drawBoard()$) und, falls nach Spielende der entsprechende Button gedrückt wurde, zum Hauptmenü zurückgekehrt werden ($backToMenu()$)
%


\section{PowerUps}
\label{PowerUps}
%
Es gibt 3 PowerUps im Spiel, welche während des Spiels von den Spielern aufgesammelt und dann aktiviert werden können, wordurch sie verbraucht werden und folgende Effekte auf die gegnerische Schlange haben: Einfrieren, Umkehrung der Steuerung oder Verkürzung der Schlange. Für alle 3 PowerUps gibt es jeweils einzelne $-exists, -X, -Y$ und $-Player$ Variablen, welche jeweils angeben, ob das jeweilige PowerUp aktuell existiert, deren X- und Y-Koordinaten sowie welcher Spieler aktuell davon betroffen ist. Außerdem gibt es die beiden Variablen $p1PowerUp$ und $p2PowerUp$, welche angeben welches PowerUp jeder Spieler gerade trägt.
Innerhalb der $powerUps()$-Funktion wird zuerst für jedes PowerUp, sowie für das $superFood$-Element, welches ähnlich funktioniert, zuerst überprüft ob es bereits auf dem Spielfeld existiert. Falls nicht, wird eine Pseudozufallszahl berechnet und mit dieser mit einer gewissen Wahrscheinlichkeit (1:50) ein neues PowerUp an einer zufälligen Stelle auf dem Feld erstellt. Falls nun ein Spieler ein PowerUp aufsammelt, was in der $collisionDetection()$ festgestellt und bearbeitet wird, wird die entsprechende PowerUp-Variable des Spielers auf den Wert des PowerUps gesetzt. Wenn nun ein Spieler ein PowerUp besitzt und aktiviert, setzt $powerUps()$ diese Variable wieder auf 0, sowie die entsprechenden Variablen des PowerUps auf ihre Aktivierungswerte. So wird zum Beispiel zum Einfrieren von Spieler 1 $playerOneFrozen$ auf 15 gesetzt. Solange $playerOneFrozen > 0$ gilt, wird für Spieler 1 anstelle eines Schrittes der Schlange der Wert von $playerOneFrozen$ dekrementiert. Die Schlange von Spieler 1 bewegt sich demnach 15 Schritte lang nicht, ist also eingefroren. Ähnlich funktioniert die Invertierung der Steuerung, hierbei wird die Variable $inverseControlOne$ auf 50 gesetzt und mit ebenfalls mit jedem Schritt invertiert. Solange die Variable größer 0 ist, wird in der Funktion $playerOneGetNextDirection()$ die entgegengesetzte Richtung der eigentlich per Tastendruck angegebenen als $nextDirection$ gesetzt. Das Reduzieren der Schlange funktioniert mit gleicher Weise, hierbei wird lediglich die Variable auf 1 gesetzt und im nächsten Schritt wieder zurück auf 0 gesetzt, zusammen mit der Verkürzung der Schlange. 
%
